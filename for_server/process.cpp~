#include "process.h"
#include <iostream>
#include <cstdlib>
using namespace Werewolf;

std::vector<logging> Process::_log;
int Process::have_police = -1;
std::vector<logging>* Chat::_log = nullptr;

Process::Process(std::vector<Client>* _all):allclient(_all), _valid(false){
    std::cout<<"All clients have been loaded.\n";
    
}

Process :: ~Process() {}

bool Process :: begin()
{
    if(!valid())
        return true;
    else return func();
}

bool Process :: valid()
{
    return _valid;
}

void Process :: activate()
{
    _valid = 1;
}

int Process::get_size(){
    return _rel_cli.size();
}

Process* Process :: next()
{
    return _next;
}

void Process :: add_client(Client* cli)
{
    _rel_cli.push_back(cli);
}

void Process :: set_next(Process* pro)
{
    _next = pro;
}

void Process :: deletelog()
{
    _log.clear();
}
std :: vector<logging>* Process::readlog(){
    return &_log;
}
void Process::writelog(Cha doer,Act act,int geter)
{
    _log.push_back(logging{doer,act,geter});
}

bool Guarding :: func()
{
    dynamic_cast<Guard*>(_rel_cli[0] -> selfCharacter()) -> who_i_guard(-1);    //å°†å®ˆå«çš„äººç½®ä¸?1
    if(!_rel_cli[0] -> selfCharacter() -> is_dead())
    {
        _rel_cli[0] -> print("Please input the player number you want to guard:\n");
        _rel_cli[0] -> turn_on_input();
        std::string res1 = _rel_cli[0]->recv();
        if ((*allclient)[atoi(res1.c_str()) - 1].selfCharacter() -> type() ==
            dynamic_cast<Guard*>(_rel_cli[0] -> selfCharacter()) -> last())
        {
            _rel_cli[0] -> print("You have guarded the same one as last night, please change\n");
            _rel_cli[0] -> print("Please input the player number you want to guard again:\n");
            _rel_cli[0] -> turn_on_input();
            std :: string res2 = _rel_cli[0] -> recv();
            (*allclient)[atoi(res2.c_str())-1].selfCharacter() -> guardfunc();
            dynamic_cast<Guard*>(_rel_cli[0] -> selfCharacter()) -> who_i_guard(atoi(res2.c_str())-1);
            writelog(GUARD, GUARDING, atoi(res2.c_str()) - 1);
        }
        else
        {
            (*allclient)[atoi(res1.c_str())-1].selfCharacter() -> guardfunc();
            dynamic_cast<Guard*>(_rel_cli[0] -> selfCharacter()) -> who_i_guard(atoi(res1.c_str()) - 1);
            writelog(GUARD, GUARDING, atoi(res1.c_str()) - 1);
        }
    }
    return true;
}

bool Killing::func(){
    int cnt=0;
    int num=-1;
    bool flag=true;
    bool isalive[_rel_cli.size()];
    for(int i=0;i<_rel_cli.size();i++)
        isalive[i]=!_rel_cli[i]->selfCharacter()->is_dead();
    while(true){
        cnt++;
        for(int i=0;i<_rel_cli.size();i++)
            if(isalive[i]){
            	_rel_cli[i] -> print("please chat with you partner:"); 
                _rel_cli[i]->turn_on_input();
                std::string words=_rel_cli[i]->recv(10);
                for(int j=0;j<_rel_cli.size();j++)
                    if(isalive[j])
                        _rel_cli[j]->print(words);
            }
        for(int i=0;i<_rel_cli.size();i++)
            if(isalive[i]){
                _rel_cli[i]->print("Please input the player number you want to kill.\nPlease reach a consensus!!!\n");
                _rel_cli[i]->turn_on_input();
                std::string tgt=_rel_cli[i]->recv(10);
                if(i==0)
                    num=atoi(tgt.c_str())-1;
                else if(num!=atoi(tgt.c_str())-1)
                    flag=false;
            }
        if(flag){
            (*allclient)[num].selfCharacter()->set_dead();
            writelog(WOLF,BITE,num);
            break;
        }
        else{
            flag=true;
            num=-1;
            for(int i=0;i<_rel_cli.size();i++)
                if(isalive[i])
                    _rel_cli[i]->print("You don't have the same target.\nYou have only "+std::to_string(5-cnt)+" chances\n");
        }
        if(cnt>=5){
            for(int i=0;i<_rel_cli.size();i++)
                if(isalive[i])
                    _rel_cli[i]->print("No chance left.You didn't kill anyone.\n");
            break;
        }
    }
    return true;
}


bool Witching :: func() //å¥³å·«ä½¿ç”¨æ¯’è¯æˆ–è€…è§£è¯
{
    if (! _rel_cli[0] -> selfCharacter() -> is_dead()) //å¥³å·«æ²¡æ­»
    {
        int pos_num = dynamic_cast<Witch*>(_rel_cli[0] -> selfCharacter()) -> have_poison();
        int anti_num = dynamic_cast<Witch*>(_rel_cli[0] -> selfCharacter()) -> have_antidote();
        //å‘Šè¯‰å‰©å¤šå°‘æ¯’è¯å’Œè§£è¯
        _rel_cli[0] -> print("You have " + std::to_string(pos_num) + " poison " + std :: to_string(anti_num) + " antidote\n");
        if (pos_num == 0 && anti_num == 0) return true;
        //è¯»æ—¥å¿—å‘Šè¯‰å¥³å·«è°æ­»è°æ´»
        if ((*readlog())[readlog() -> size() - 1]._act == 0)
        {
            int have_dead = (*readlog())[readlog() -> size() - 1]._geter;
            _rel_cli[0] -> print("Player " + std::to_string(have_dead + 1) + " have been killed by werewolves\n");
        }
        else _rel_cli[0] -> print("no one dead\n");
        
        //è¯·å¥³å·«é€‰æ‹©æ¯’è¯å’Œè§£è¯
        _rel_cli[0] -> print("Please choose to use poison or antidote, p or a or n for nothing\n");
        _rel_cli[0] -> turn_on_input();
        std::string drug = _rel_cli[0] -> recv();
        if (drug == "n")
            return true;
        while(1)
        {
            if (drug == "p")
            {
                if (pos_num == 0)
                {
                    _rel_cli[0] -> print("ERROR, NO Posion left, please input again\n");
                    _rel_cli[0] -> turn_on_input();
                    drug = _rel_cli[0] -> recv();
                }
                else break;
            }
            
            if (drug == "a")
            {
                if (pos_num == 0)
                {
                    _rel_cli[0] -> print("ERROR, NO antidote left, please input again\n");
                    _rel_cli[0] -> turn_on_input();
                    drug = _rel_cli[0] -> recv();
                }
                else break;
            }
        }
        
        
        if (drug == "p")    //æ¯’äºº
        {
            _rel_cli[0] -> print("Please Input the player you want to poison\n");
            _rel_cli[0] -> turn_on_input();
            std::string ans = _rel_cli[0] -> recv();
            int num = atoi(ans.c_str());
            writelog(WITCH, POISON, num - 1);
        }
        else
        {
            int have_dead = (*readlog())[readlog() -> size() - 1]._geter;
            writelog(WITCH, SAVE, have_dead);
        }
    }
    return true;
}

Voting::Voting(std::vector<Client>* _all, Process* hunt,Process* Po_passing ):Process(_all), ht(hunt),Po_p(Po_passing){}
Po_passing::Po_passing(std::vector<Client>* _all):Process(_all){}
bool Voting::func(){
    int n=allclient->size();
    bool isalive[n];//â€â€“Ã€â‰ â€˜â„â‰¥Â°
    double num[n];//ÂºÂ«Â¬ÂºâˆšÃ¸âˆË†Â»Ã€Â±ÂªÃ•âˆ‚âˆ†Â± Ë
    int voteinfo[n];//ÂºÂ«Â¬ÂºâˆšÃ¸âˆË†Â»Ã€Ã•âˆ‚âˆ†Â±Â«ÃˆÃ¸Ë†
    std::vector<int> player;
    for(int i=0;i<n;i++){
        isalive[i]=!(*allclient)[i].selfCharacter()->is_dead();
        if(isalive[i])
            player.push_back(i);
        num[i]=0;
        voteinfo[i]=-1;
    }
    std::string voted="You can vote to Player";
    for(int i=0;i<player.size();i++){
        voted+=" "+std::to_string(i+1);
    }
    voted+=".\n";
    if(have_police>=0){//Ã¦Ã˜â‰¥Â§Ï€Ãˆâˆ†Â±
        (*allclient)[have_police].print("Please vote a Player!\n");
        (*allclient)[have_police].turn_on_input();
        std::string pt=(*allclient)[have_police].recv();
        while(!isalive[pt[0]-'1']){
            (*allclient)[have_police].print("Please choose another Player!, he is dead\n");
            (*allclient)[have_police].turn_on_input();
            pt=(*allclient)[have_police].recv();
        }
        voteinfo[have_police]=pt[0]-'1';
        num[pt[0]-'1']+=1.5;
    }
    for(int i=0;i<n;i++)//âˆ†â€°â€â€¡Â»Ã€Ã•âˆ‚âˆ†Â±
        if(isalive[i]||i!=have_police){
            (*allclient)[i].print("Please vote!\n"+voted);
            if(have_police>=0)
                (*allclient)[i].print("The Police votes to Player "+std::to_string(voteinfo[have_police]+1)+".\n");
            (*allclient)[i].turn_on_input();
            std::string tgt=(*allclient)[i].recv();
            while(!isalive[tgt[0]-'1']){
                (*allclient)[i].print("Please choose another Player!, he is dead\n");
                (*allclient)[i].turn_on_input();
                tgt=(*allclient)[i].recv();
            }
            voteinfo[i]=tgt[0]-'1';
            num[tgt[0]-'1']+=1.0;
        }
    double maxx=0;//âˆ†Â± ËÂµÆ’â—ŠÃ“Â¥Ã›Ã·Âµ
    std::vector<int> maxnum;//âˆ†Â± Ëâ—ŠÃ“Â¥Ã›ÂµÆ’Â»Ã™âˆâ€¦âˆšËšÃ•ÃŠÂºâ€œÂµÆ’Â±â€¡âˆ«â‰ˆ
    for(int i=0;i<n;i++)
        if(num[i]>maxx)
            maxx=num[i];
    for(int i=0;i<n;i++)
        if(abs(num[i]-maxx)<1e-9)
            maxnum.push_back(i);
    std::string s="";//â€“Ã‹â€œâ„¢Â¥Ãšâ€Â°ÂµÆ’Ã•âˆ‚âˆ†Â±â€“â‰ˆÅ“Â¢
    for(int i=0;i<n;i++)
        if(isalive[i])
            s+="Player "+std::to_string(i+1)+" votes to Player "+std::to_string(voteinfo[i]+1)+".\n";
    
    for(int i=0;i<n;i++)//Ï€Â´â‰¤ÂºÃ•âˆ‚âˆ†Â±â€“â‰ˆÅ“Â¢
        if(isalive[i])
            (*allclient)[i].print(s);
    
    std::vector<int> deadnum;//Ã€Â¿â€™ï¬‚â€“â‰ˆÅ“Â¢
    if(maxnum.size()==1){
        (*allclient)[maxnum[0]].selfCharacter()->set_dead();
        isalive[maxnum[0]]=0;
        writelog(ALL,VOTE,maxnum[0]);
        deadnum.push_back(maxnum[0]);
        /*
         for(int i=0;i<n;i++)
         if(isalive[i])
         (*allclient)[i].print("Player "+std::to_string(maxnum[0])+" has been voted out!\n");
         (*allclient)[maxnum[0]].print("You have been voted out!\n");
         if(!is_end()){
         if((*allclient)[maxnum[0]].selfCharacter()->type()==hunter){
         bool end=!ht->begin();*/
        /*
         (*allclient)[maxnum[0]].print("You can choose to shoot or not.(Y/N)\n");
         (*allclient)[maxnum[0]].turn_on_input();
         std::string choice=(*allclient)[maxnum[0]].recv();
         if(choice=="Y"){
         bool end=!ht->begin();//Ã¸ÂºÂ¬Â«Â¡â€˜Â»Ã€â€¦Â±Â»Ã€âˆ«Ã›Î©Â·Ã€â€*/
        /*
         if(end)
         return false;
         }
         }
         */
        /*
         for(int i=0;i<n;i++)
         isalive[i]=!(*allclient)[i].selfCharacter()->is_dead();//âˆÂ¸â€“Â¬isalive[]*/
        /*
         for(int i=0;i<n;i++)
         if(isalive[i]||i==maxnum[0])
         (*allclient)[i].print("Last words begin.\n");
         (*allclient)[maxnum[0]].print("Please input the words you want to say before you quit the game.\n:q + Enter represents ending.\n");
         std::string lwords="";
         while(true){
         (*allclient)[maxnum[0]].turn_on_input();
         lwords=(*allclient)[maxnum[0]].recv();
         if(lwords!=":q"){
         for(int j=0;i<n;j++)
         if(isalive[j]){
         (*allclient)[j].print(lwords+"\n");
         }
         }
         else break;
         }
         for(int i=0;i<n;i++)
         if(isalive[i]||i==maxnum[0])
         (*allclient)[i].print("Last words end.\n");
         (*allclient)[maxnum[0]].print("You quit the game.\n");
         return true;
         }
         else
         return false;*/
    }
    else{
        std::string tie="Player";
        for(int i=0;i<maxnum.size();i++)
            tie+=" "+std::to_string(maxnum[i]+1);
        tie+=" have the same number of votes.\nRound 2 Chat begins.\nAt the following order:\n\tPlayer";
        int r1=rand()%maxnum.size();
        int r2=rand()%2;
        int order=0;
        if(r2==0)
            order=1;
        else
            order=-1;
        std::vector<int> chod;
        for(int i=0;i<maxnum.size();i++)
            chod.push_back(maxnum[(r1+i*order+maxnum.size())%maxnum.size()]);
        for(int i=0;i<maxnum.size();i++)
            tie+=" "+std::to_string(chod[i]+1);
        for(int i=0;i<n;i++)
            (*allclient)[i].print(tie);
        for(int i=0;i<chod.size();i++){
            for(int j=0;j<n;j++)
                if(isalive[j])
                    (*allclient)[j].print("Player "+ std::to_string(chod[i]+1)+"'s turn:\n");
            (*allclient)[chod[i]].print("Please input the words you want to say.\n:q + Enter represents ending.\n");
            std::string saying="";
            while(true){
                (*allclient)[chod[i]].turn_on_input();
                saying=(*allclient)[chod[i]].recv();
                if(saying!=":q")
                    for(int j=0;j<n;j++)
                        if(isalive[j]&&j!=chod[i])
                            (*allclient)[j].print(saying);
                        else break;
            }
            for(int j=0;j<n;j++)
                (*allclient)[j].print("Player "+std::to_string(chod[i]+1)+"has finished.\n");
        }
        for(int i=0;i<n;i++)
            (*allclient)[i].print("Round 2 Chat end.\nRound 2 Voting start.\n");
        int num2[n];//âˆšÃ¸âˆË†Â»Ã€Â±ÂªÃ•âˆ‚âˆ†Â±
        int voteinfo2[n];//âˆšÃ¸âˆË†Â»Ã€Ã•âˆ‚âˆÂ¯Ã€â‰ 
        int maxx=0;//â—ŠÃ“âˆ‚â€¡âˆ†Â± Ë
        bool canvote[n];
        for(int i=0;i<n;i++){
            num2[i]=0;
            voteinfo2[i]=-1;
            canvote[i]=1;
        }
        for(int i=0;i<maxnum.size();i++){
            canvote[maxnum[i]]=0;
        }
        std::string sec="You can only vote to Player";
        for(int i=0;i<maxnum.size();i++)
            sec+=" "+std::to_string(maxnum[i]+1);
        sec+=".\n";
        maxnum.clear();//Â«Ã‚Ã¸â€™â—ŠÃ“âˆ‚â€¡âˆ†Â± ËÂµÆ’Ã•ÃŠÂºâ€œâ€“ÃšÂ¡â€“
        for(int i=0;i<n;i++){
            if(isalive[i]&&canvote[i]){
                (*allclient)[i].print("Please vote!\n"+sec);
                (*allclient)[i].turn_on_input();
                std::string st=(*allclient)[i].recv();
                while(canvote[st[0]-'1']){
                    (*allclient)[i].print("You cannot vote that Player.\nPlease choose another Player.\n");
                    st=(*allclient)[i].recv();
                }
                voteinfo2[i]=st[0]-'1';
                num2[st[0]-'1']++;
            }
        }
        for(int i=0;i<n;i++)
            if(num2[i]>maxx)
                maxx=num2[i];
        for(int i=0;i<n;i++)
            if(num2[i]==maxx)
                maxnum.push_back(i);
        std::string secs="";//â€“Ã‹â€œâ„¢Â¥Ãšâ€Â°ÂµÆ’Ã•âˆ‚âˆ†Â±â€“â‰ˆÅ“Â¢
        for(int i=0;i<n;i++)
            if(isalive[i]&&canvote[i])
                secs+="Player "+std::to_string(i+1)+" votes to Player "+std::to_string(voteinfo2[i]+1)+".\n";
        for(int i=0;i<n;i++)//Ï€Â´â‰¤ÂºÃ•âˆ‚âˆ†Â±â€“â‰ˆÅ“Â¢
            if(isalive[i])
                (*allclient)[i].print(s);
        for(int i=0;i<maxnum.size();i++){//Ã€Â¿Ã•Ë†â‰¤Å¸â—ŠËœ
            (*allclient)[maxnum[i]].selfCharacter()->set_dead();
            //	isalive[maxnum[i]]=0;
            writelog(ALL,VOTE,maxnum[i]);
            deadnum.push_back(maxnum[i]);
        }
    }
    //Ï€Â´â‰¤ÂºÃ€Â¿â€™ï¬‚â€“â‰ˆÅ“Â¢ÂºâˆÎ©Â¯â€“â€“âˆ«Ã›â€“Â¯Â¥Â¶Â¿ÃŒ
    std::string deathinfo="Player";
    for(int i=0;i<deadnum.size();i++)
        deathinfo+=" "+std::to_string(deadnum[i]+1);
    deathinfo+=" out!\n";
    for(int i=0;i<n;i++)
        if(isalive[i])
            (*allclient)[i].print(deathinfo);
    bool isend=is_end();
    if(isend)
        return false;
    else{//â€Å’Å“âˆ‘â‰¤Â¢Å’Â¥Î©Â· Â¯ Î©Â¯â€“â€“Ã¦Ã˜â‰¥Â§âˆ‘â€¦Ã¦Ã˜Âªâ€™âˆ«Ã•Â¡â€˜Â»Ã€Ã¸â„¢Â«Ï€
        bool flag1=0;
        bool flag2=0;
        for(int i=0;i<deadnum.size();i++)
            if(deadnum[i]==have_police){
                flag1=1;
                break;
            }
        if(flag1)//Ã¦Ã˜â‰¥Â§âˆ‘â€¦Ã¦Ã˜Âªâ€™
            Po_p->begin();
        
        for(int i=0;i<deadnum.size();i++)
            if((*allclient)[deadnum[i]].selfCharacter()->type()==hunter){
                flag2=deadnum[i];
                break;
            }
        if(flag2>=0){//Â¡â€˜Â»Ã€Ã¸â„¢Â«Ï€
            ht->begin();
            bool isend2=is_end();
            if(isend2)
                return false;
            else{//Ã¦Ã˜â‰¥Â§âˆ‘â€¦Ã¦Ã˜Âªâ€™
                int behunt=(*readlog())[readlog()->size()-1]._geter;
                if(behunt==have_police)
                    Po_p->begin();
            }
        }
        //â€œâ‰ˆâ€”â€˜â‰¥Â¬ Ë†
        deadnum.clear();
        for(int i=_log.size()-1;i>=0;i--)
            if(_log[i]._act==VOTE||_log[i]._act==SHOOT)
                deadnum.push_back(_log[i]._geter);
            else
                break;
        for(int i=0;i<n;i++)
            isalive[i]=!(*allclient)[i].selfCharacter()->is_dead();
        for(int i=0;i<deadnum.size();i++)
            isalive[deadnum[i]]=1;
        for(int i=deadnum.size()-1;i>=0;i--){
            (*allclient)[deadnum[i]].print("Please input your last words.\n:q + Enter represents ending.\n");
            (*allclient)[deadnum[i]].turn_on_input();
            std::string lword="Player "+std::to_string(deadnum[i]+1)+"'s last wotds start:\n";
            std::string ladd="";
            ladd=(*allclient)[deadnum[i]].recv();
            while(ladd!=":q"){
                lword+=ladd+"\n";
                (*allclient)[deadnum[i]].turn_on_input();
                ladd=(*allclient)[deadnum[i]].recv();
            }
            lword+="Last words end.\n";
            for(int j=0;j<n;j++)
                if(isalive[j]&&j!=deadnum[i])
                    (*allclient)[j].print(lword);
            (*allclient)[deadnum[i]].print("You quit the game!\n");
            isalive[deadnum[i]]=0;
        }
    }
    return true;
}
bool Voting::is_end(){
    int wolfnum=0;
    int villnum=0;
    int godnum=0;
    int n=allclient->size();
    for(int i=0;i<n;i++)
        if(!(*allclient)[i].selfCharacter()->is_dead()){
            int tp=(*allclient)[i].selfCharacter()->type();
            if(tp==wolf)
                wolfnum++;
            else if(tp==villager)
                villnum++;
            else godnum++;
        }
    if(wolfnum==0&&villnum!=0&&godnum!=0){
        for(int i=0;i<n;i++)
            (*allclient)[i].print("Good Man Win!\n");
        return true;
    }
    if(wolfnum==0&&(villnum==0||godnum==0)){
        for(int i=0;i<n;i++)
            (*allclient)[i].print("Tie Game!\n");
        return true;
    }
    if(wolfnum!=0&&(villnum==0||godnum==0)){
        for(int i=0;i<n;i++)
            (*allclient)[i].print("Wolf Win!\n");
    }
    if(wolfnum!=0&&villnum!=0&&godnum!=0)
        return false;
    
    return true;
}
void Calculating::find_dead(){
	for(int i = 0; i < (*allclient).size(); i++){
		if((*_log)[1]._geter == i){
			(*allclient)[i].selfCharacter() -> set_dead();
		}
	}
}
bool Calculating::is_guarded(int i){
    if((*_log)[0]._geter == i){
        return true;
    }
    return false;
}

bool Calculating::is_saved(int i){
    if((*_log)[1]._geter == i && (*_log)[1]._act == 2){
        return true;
    }
    return false;
}

bool Calculating::is_poisoned(int i){
    if((*_log)[1]._geter == i && (*_log)[1]._act == 1){
        return true;
    }
    return false;
}

bool Calculating::calculatewolf(){//âˆ‘Ã·Ã¦Ã˜Âªâ€™âˆ«Ã•âˆ‘â€¦Ã¦Ã˜Âªâ€™âˆšÂªâ€â€“ ÂµÅ“Ã·
    int sum = 0;
    int num = 0;
    std::vector<Client>& m = *allclient;
    for(auto i = 0; i < m.size(); i++){
        if(m[i].selfCharacter() -> type() == 1){
            sum++;
            if(m[i].selfCharacter() -> is_dead() == true){
                if(is_guarded(i) && is_saved(i)){
                    num++;
                    if(m[i].selfCharacter() -> is_police()){
                        officer = i;
                    }
                    
                    //willing(&m[i]);
                }
                else if(is_guarded(i)){
                    m[i].selfCharacter() -> set_alive();//Â±Âª Ã¿Å’Â¿ÂµÆ’Â»Ã€Ã·â„¢ÂµÂ¿â—Šâ€˜Âºâˆ«Â±Âª Ã¿Å’Â¿âˆšÂ¥Â£Ã¸
                }
                else if(is_saved(i)){
                    m[i].selfCharacter() -> set_alive();
                }
                else{
                    num++;
                    if(m[i].selfCharacter() -> is_police()){
                        officer = i;
                    }
                    //willing(&m[i]);
                }
            }
            else{
                if(is_poisoned(i)){
                    num++;
                    if(m[i].selfCharacter() -> is_police()){
                        officer = i;
                    }
                    //willing(&m[i]);
                }
            }
        }
        if(num == sum){
            return true;
        }
        return false;
    }
    return true;
}

bool Calculating::calculatepeo(){
    int sum = 0;
    int num = 0;
    std::vector<Client>& m = *allclient;
    for(auto i = 0; i < m.size(); i++){
        for(auto i = 0; i < m.size(); i++){
            if(m[i].selfCharacter() -> type() == 2){
                sum++;
                if(m[i].selfCharacter() -> is_dead() == true){
                    if(is_guarded(i) && is_saved(i)){
                        num++;
                        if(m[i].selfCharacter() -> is_police()){
                            officer = i;
                        }
                        //willing(&m[i]);
                    }
                    else if(is_guarded(i)){
                        m[i].selfCharacter() -> set_alive();//Â±Âª Ã¿Å’Â¿ÂµÆ’Â»Ã€Ã·â„¢ÂµÂ¿â—Šâ€˜Âºâˆ«Â±Âª Ã¿Å’Â¿âˆšÂ¥Â£Ã¸
                    }
                    else if(is_saved(i)){
                        m[i].selfCharacter() -> set_alive();
                    }
                    else{
                        num++;
                        if(m[i].selfCharacter() -> is_police()){
                            officer = i;
                        }
                        //willing(&m[i]);
                    }
                }
                else{
                    if(is_poisoned(i)){
                        num++;
                        if(m[i].selfCharacter() -> is_police()){
                            officer = i;
                        }
                        //willing(&m[i]);
                    }
                }
            }
        }
        if(num == sum){
            return true;
        }
        return false;
    }
    return true;
}

bool Calculating::calculategod(){
    int sum = 0;
    int num = 0;
    std::vector<Client>& m = *allclient;
    for(auto i = 0; i < m.size(); i++){
        if((m[i].selfCharacter() -> type() != 1 )&&(m[i].selfCharacter() -> type() != 2) && (m[i].selfCharacter() -> type() != 3)){
            sum++;	
            if(m[i].selfCharacter() -> is_dead() == true){
                if(is_guarded(i) && is_saved(i)){
                    num++;
                    if(m[i].selfCharacter() -> is_police()){
                        officer = i;
                    }
                    //willing(&m[i]);
                }
                else if(is_guarded(i)){
                    m[i].selfCharacter() -> set_alive();//Â±Âª Ã¿Å’Â¿ÂµÆ’Â»Ã€Ã·â„¢ÂµÂ¿â—Šâ€˜Âºâˆ«Â±Âª Ã¿Å’Â¿âˆšÂ¥Â£Ã¸
                }
                else if(is_saved(i)){
                    m[i].selfCharacter() -> set_alive();
                }
                else{
                    num++;
                    if(m[i].selfCharacter() -> is_police()){
                        officer = i;
                    }
                    //willing(&m[i]);
                }
            }
            else{
                if(is_poisoned(i)){
                    num++;
                    if(m[i].selfCharacter() -> is_police()){
                        officer = i;
                    }
                    //willing(&m[i]);
                }
            }
        }
    }
    if(num == sum){
        return true;
    }
    return false;
}

bool Calculating::func(){
	find_dead();
    if(_calibra == 1){
        if(calculatewolf() || calculatepeo() || calculategod()){
            return false;
        }
        else{
			if((*allclient)[officer].selfCharacter() -> is_police()){
				_po -> func();
			}
            return true;
        }
        
    }
    else{
        if(calculatewolf() || calculategod() || calculatepeo()){
            return false;
        }
		else{
			if((*allclient)[officer].selfCharacter() -> is_police()){
				_po -> func();
			}
			return true;
		}
        }
    }


bool check(int* a, int size, int k) //æ£€æµ‹æ•°ç»„ä¸­æœ‰æ²¡æœ‰æŸä¸ªå…ƒç´ k
{
    for (int i = 0; i < size; i++)
        if (a[i] == k) return true;
    return false;
}

bool Po_electing :: func()  //é€‰ä¸¾è­¦é•¿
{
    have_police = -1; //æ²¡æœ‰è­¦é•¿ï¼Œå¦åˆ™è¡¨ç¤ºç©å®¶ç¼–å·
    int *num, cnt = 0;   //numä¸­å­˜ç«é€‰è­¦é•¿çš„äººçš„ç¼–å·ï¼Œcntè¡¨ç¤ºç«é€‰è­¦é•¿çš„äººçš„ä¸ªæ•°
    int *tot_poll;  //è®°å½•æ¯ä¸ªç«é€‰è­¦é•¿çš„ç©å®¶æ‰€å¾—ç¥¨æ•°ï¼Œä¸numç›¸å¯¹åº”
    int max_poll = 0;   //è¡¨ç¤ºæœ€å¤§ç¥¨æ•°ï¼Œé˜²æ­¢æœ‰é‡å¤è¦é‡æ–°è®¡ç¥¨
    for (int i = 0; i < (*allclient).size(); i++)   //éå†è¯¢é—®æƒ³å½“è­¦é•¿çš„äºº
    {
        if (! (*allclient)[i].selfCharacter() -> is_dead())
        {
            (*allclient)[i].print("Do you want to be police, y or n?\n");
            (*allclient)[i].turn_on_input();
            std::string ans = (*allclient)[i].recv();
            if (ans[0] == 'y')
                num[cnt++] = i + 1; //è®°å½•ä¸‹æƒ³å½“è­¦é•¿çš„äººçš„ç¼–å·
        }
    }
    
    for (int i = 0; i < cnt && num[i] != 0; i++)
    {
        (*allclient)[num[i]].print("Please input your Declaration of candidacy\n");
        (*allclient)[num[i]].turn_on_input();
        std::string words = (*allclient)[num[i]].recv(); //æ¥å—ç«é€‰å®£è¨€
        for (int j = 0; j < (*allclient).size(); j++)//å°†ç«é€‰å®£è¨€å‘ç»™æ‰€æœ‰ç©å®¶
            (*allclient)[j].print("words from player " + std::to_string(num[i]) + " is" + words);
        
        
        for (int j = 0; j < cnt && num[j] != 0; j++)    //æ¯ä½ç«é€‰è€…å‘è¨€åè¯¢é—®æ˜¯å¦æœ‰äººé€€å‡ºç«é€‰
        {
            (*allclient)[num[j]].print("Do you want to quit electing, q or n");
            (*allclient)[num[j]].turn_on_input();
            std::string ans = (*allclient)[num[j]].recv();   //å¾—åˆ°ä¿¡æ¯æ˜¯å¦é€€æ°´
            if (ans[0] == 'q')
                num[j] = 0;  //é€€æ°´åˆ™å°†ç¼–å·ç½®ä¸º0
        }
        
    }
    for (int i = 0; i < (*allclient).size(); i++)
    {
        if (! (*allclient)[i].selfCharacter() -> is_dead() && !check(num, cnt, i))  //æ²¡æœ‰æ­»ä¸”ä¸å‚åŠ ç«é€‰
        {
            for (int j = 0; j < cnt; j++)
            {
                if (num[i])
                    (*allclient)[i].print("player involved in election include " + std::to_string(num[i]));
            }
            (*allclient)[i].print("Please input the player you want to choose to be the police\n");
            (*allclient)[i].turn_on_input();
            std::string ans = (*allclient)[i].recv();
            for (int l = 0; l < cnt; l++)
            {
                if (num[l] == atoi(ans.c_str()))    //æ‰¾åˆ°ç›¸åº”çš„äººå¹¶è®¡ç¥¨
                {
                    tot_poll[l] += 1;
                    break;
                }
            }
        }
    }
    int target = 0; //è®°å½•æœ€å¤§ç¥¨æ•°çš„äºº
    //ç¥¨æ•°ç›¸åŒå†æ¬¡å‘è¨€å¹¶é‡æ–°æŠ•ç¥¨
    for (int i = 0; i < cnt; i++)   //å¼€å§‹å¯»æ‰¾æœ€å¤§ç¥¨æ•°
    {
        if (tot_poll[i] > max_poll)
        {
            max_poll = tot_poll[i];
            target = i;
        }
    }
    std::vector<int> rep;    //è®¡ç®—æœ‰æœ€å¤§ç¥¨æ•°çš„äººæ•°
    for (int i = 0; i < cnt; i++)
    {
        if (tot_poll[i] == max_poll)
            rep.push_back(num[i]);
    }
    if(rep.size() == 1)    have_police = target;   //è­¦é•¿
    else    //æœ‰å¤šäººåŒç¥¨
    {
        for (int i = 0; i < (*allclient).size(); i++) //å‘æ¯ä¸ªäººå‘é€æ¶ˆæ¯
        {
            for (int j = 0; j < rep.size(); j++)
            {
                (*allclient)[i].print("Player " + std::to_string(rep[j]) + " have the same poll, please say and vote again");
            }
        }
        for (int i = 0; i < rep.size(); i++) //åŒç¥¨è€…é‡æ–°å‘è¨€
        {
            (*allclient)[rep[i]].print("Please input your declaration again\n");
            (*allclient)[rep[i]].turn_on_input();
            std::string words = (*allclient)[rep[i]].recv();
            for (int j = 0; j < (*allclient).size(); i++)
                (*allclient)[j].print(words);
        }
        for (int i = 0; i < cnt; i++)
        {
            for (int j = 0; j < rep.size(); j++)
            {
                if (rep[j] == num[i])   break;
                num[i] = 0; //å°†ç¬¬ä¸€æ¬¡ç«é€‰çš„ç¥¨æ•°å°‘çš„è¸¢å‡ºï¼Œåæ¥è¦è¿›è¡ŒæŠ•ç¥¨
            }
        }
        for (int i = 0; i < cnt; i++)
            tot_poll[i] = 0;    //ç¥¨æ•°æ¸…ç©º
        for (int i = 0; i < (*allclient).size(); i++)   //é‡æ–°è®¡ç¥¨
        {
            if (!(*allclient)[i].selfCharacter() -> is_dead() && !check(num, cnt, i))  //æ²¡æœ‰æ­»ä¸”ä¸å‚åŠ ç«é€‰
            {
                
                (*allclient)[i].print("Please input the player you want to choose to be the police again\n");
                (*allclient)[i].turn_on_input();
                std::string ans = (*allclient)[i].recv();
                for (int l = 0; l < cnt; l++)
                {
                    if (num[l] == atoi(ans.c_str()))    //æ‰¾åˆ°ç›¸åº”çš„äººå¹¶è®¡ç¥¨
                    {
                        tot_poll[l] += 1;
                        break;
                    }
                }
            }
        }//é‡æ–°è®¡ç¥¨ç»“æŸ
        max_poll = 0, target = 0;
        for (int i = 0; i < cnt; i++)   //å†æ¬¡å¼€å§‹å¯»æ‰¾æœ€å¤§ç¥¨æ•°
        {
            if (tot_poll[i] > max_poll)
            {
                max_poll = tot_poll[i];
                target = i;
            }
        }
        std::vector<int> rep2;    //è®¡ç®—æœ‰æœ€å¤§ç¥¨æ•°çš„äººæ•°
        for (int i = 0; i < cnt; i++)
        {
            if (tot_poll[i] == max_poll)
                rep2.push_back(num[i]);
        }
        if(rep2.size() == 1)    have_police = target;   //è­¦é•¿
        //elseæ— è­¦é•¿
    }
    
    _valid = false; //æ‰§è¡Œå®Œä¸€æ¬¡åç›´æ¥ä¸å†å¯ç”¨ï¼ˆåªç«é€‰ä¸€æ¬¡è­¦é•¿ï¼‰
    return true;
}

bool Po_passing::func(){
    int n=allclient->size();
    bool isalive[n];
    for(int i=0;i<n;i++)
        isalive[i]=!(*allclient)[i].selfCharacter()->is_dead();
    for(int i=_log.size()-1;i>=0;i--){
        if(_log[i]._act==VOTE)
            isalive[_log[i]._geter]=1;
        else break;
    }
    for(int i=0;i<n;i++)
        if(isalive[i])
            (*allclient)[i].print("The Police Out!\n");
    
    (*allclient)[have_police].print("Please choose to pass the police to someone or not.(Y/N)\n");
    (*allclient)[have_police].turn_on_input();
    std::string pp="";
    pp=(*allclient)[have_police].recv();
    while(pp[0]!='Y'&&pp[0]!='N'){
        (*allclient)[have_police].print("Input again.\n");
        (*allclient)[have_police].turn_on_input();
        pp=(*allclient)[have_police].recv();
    }
    if(pp[0]=='N'){
        for(int i=0;i<n;i++)
            if(isalive[i])
                (*allclient)[i].print("The Police chooses to tear the pooolice sign.\n");
        have_police=-1;
        _rel_cli.clear();
    }
    else{
        (*allclient)[have_police].print("Please choose a Player to be the next Police.\n\tJust input player number.\n");
        std::string pass="";
        (*allclient)[have_police].turn_on_input();
        pass=(*allclient)[have_police].recv();
        while((*allclient)[pass[0]-'1'].selfCharacter()->is_dead()){
            (*allclient)[have_police].print("That Player is dead.\nPlease choose another Player.\n");
            pass=(*allclient)[have_police].recv();
        }
        for(int i=0;i<n;i++)
            if(isalive[i])
                (*allclient)[i].print("The Police chooses Player "+std::to_string(pass[0]-'1')+" to be the next Police.\n");
        have_police=pass[0]-'1';
        _rel_cli.clear();
        _rel_cli.push_back(&((*allclient)[have_police]));
    }
    return true;
}

Chat :: Chat(std::vector<Client>* _cli) : Process(_cli)
{
    size = _cli -> size();
}

void Chat :: read()//è·å–dead_num,dead_player[],
{
    
    int bite_man = -1;
    int poison_man = -1;
    int save_man = -1;
    int guard_man = -1;
    memset(dead_player, -1, sizeof(dead_player));
    _log = readlog();
    for(int i=0 ; i<_log -> size() ; i++)//åˆ¤æ–­æœ‰æ²¡æœ‰è¢«å’¬æˆ–è€…è¢«æ¯’,è¢«å®ˆå«ï¼Œè¢«æ•‘
    {
        if((*_log)[i]._act == BITE)
            bite_man = (*_log)[i]._geter;
        if((*_log)[i]._act == POISON)
            poison_man = (*_log)[i]._geter;
        if((*_log)[i]._act == SAVE)
            save_man = (*_log)[i]._geter;
        if((*_log)[i]._act == GUARDING)
            guard_man = (*_log)[i]._geter;
    }
    for(int i=0 ; i<size ; i++)//åˆ¤æ–­æœ‰æ²¡æœ‰è¢«å®ˆå«æˆ–è€…è¢«æ•‘
    {
        if((bite_man == i)&&(poison_man != i)&&(guard_man != i))//è¢«å’¬ï¼Œä¸è¢«æ•‘ï¼Œä¸è¢«å®ˆå«
        {
            dead_num++;
            dead_player[dead_num]=i;
        }
        if((poison_man == i)&&(guard_man != i)) //  è¢«æ¯’ï¼Œä¸è¢«å®ˆå«
        {
            dead_num++;
            dead_player[dead_num]=i;
        }
        if((bite_man == i)&&(poison_man == i)&&(guard_man = i))//è¢«å’¬ï¼ŒåŒå®ˆåŒæ•‘
        {
            dead_num++;
            dead_player[dead_num]=i;
        }
    }
}

void Chat :: right()
{
    read();
    for(int m=start_one+1; m < size; m++)
    {
        if(! client[m].selfCharacter() -> is_dead())
        {
            client[m].print("Please input your massages:");
            client[m].turn_on_input();
            std::string s = client[m].recv();
            for(int k = 0; k < size; k++)
            {
                if(! client[k].selfCharacter() -> is_dead())
                {
                    client[k].print("this is player " + std::to_string(m + 1) + "\n");
                    client[k].print(s);
                }
            }
        }
    }
    for(int m = 0 ; m <start_one ; m++)
    {
        if(! client[m].selfCharacter() -> is_dead())
        {
            client[m].print("Please input your massages:");
            client[m].turn_on_input();
            std::string s = client[m].recv();
            for(int k = 0; k < size; k++)
            {
                if(! client[k].selfCharacter() -> is_dead())
                {
                    client[k].print("this is player " + std::to_string(m + 1) + "\n");
                    client[k].print(s);
                }
            }
        }
    }
}

void Chat :: left()
{
    read();
    int size = client.size();
    if(start_one==0)
    {
        for(int m = size-1; m > 0; m--)
        {
            if(! client[m].selfCharacter() -> is_dead())
            {
                client[m].print("Please input your massages:");
                client[m].turn_on_input();
                std::string s = client[m].recv();
                for(int k = 0; k < size; k++)
                {
                    if(! client[k].selfCharacter() -> is_dead())
                    {
                        client[k].print("this is player " + std::to_string(m + 1) + "\n");
                        client[k].print(s);
                    }
                }
            }
        }
        
    }
    else
    {
        for(int m = start_one-1; m>=0 ; m--)
        {
            if(! client[m].selfCharacter() -> is_dead())
            {
                client[m].print("Please input your massages:");
                client[m].turn_on_input();
                std::string s = client[m].recv();
                for(int k = 0; k < size; k++)
                {
                    if(! client[k].selfCharacter() -> is_dead())
                    {
                        client[k].print("this is player " + std::to_string(m + 1) + "\n");
                        client[k].print(s);
                    }
                }
            }
        }
        for(int m = size-1; m >=start_one+1 ; m--)
        {
            if(! client[m].selfCharacter() -> is_dead())
            {
                client[m].print("Please input your massages:");
                client[m].turn_on_input();
                std::string s = client[m].recv();
                for(int k = 0; k < size; k++)
                {
                    if(! client[k].selfCharacter() -> is_dead())
                    {
                        client[k].print("this is player " + std::to_string(m + 1) + "\n");
                        client[k].print(s);
                    }
                }
            }
        }
    }
}


bool Chat :: func()
{
    read();
    for(int i=0 ; i < size ; i++)//é—è¨€ç¯èŠ‚
    {
        for(int j=1 ; j<=dead_num ; j++)
        {
            if(dead_player[j] == i)
            {
                client[i].print("Please input your last words:");
                client[i].turn_on_input();
                std::string s = client[i].recv();
                for(int k = 0; k<size ; k++)
                    client[k].print(s);
            }
        }
    }
    for(int i=0 ; i < size ; i++)
    {
        if(have_police == i)//iæ˜¯è­¦é•¿
        {
            police=1;//è¡¨ç¤ºæœ‰è­¦é•¿å­˜åœ¨
            if (dead_num==1)
            {
                start_one=dead_player[1];
                client[i].print("Please choose left or right:");
                client[i].turn_on_input();;
                std::string p = client[i].recv();
                if( p == "right")//å‘å³
                    right();
                else
                    left();
            }
            else
            {
                start_one=i;
                client[i].print("Please choose left or right:");
                client[i].turn_on_input();
                std::string p = client[i].recv();
                if( p == "right")//å‘å³
                    right();
                else
                    left();
            }
        }
        else
            continue;
    }
    if(police==0)//è­¦é•¿ä¸å­˜åœ¨çš„æƒ…å†µ
    {
        if(dead_num==1)
        {
            start_one = dead_player[1];
            srand( (unsigned)time( NULL ) );
            int left_right = rand() % 2;//0ä¸ºå·¦ï¼Œ1ä¸ºå³
            if(left_right==1)
                right();
            else
                left();
        }
        else
        {
            srand( (unsigned)time( NULL ) );
            int t =  rand() % dead_num + 1;
            start_one = dead_player[t];
            int left_right = rand() % 2;
            if(left_right==1)
                right();
            else
                left();
        }
        
    }
    return true;
}

bool Hunting :: func()
{
    std::vector <Client>& tep_cli = *_cli;
    for(int i = 0 ; i < tep_cli.size() ; i++)
    {
        if(tep_cli[i].selfCharacter() -> type() == 3)//åˆ¤æ–­æ˜¯ä¸æ˜¯çŒäºº
        {
            tep_cli[i].print("Please choose a man you want to kill");
            tep_cli[i].turn_on_input();
            std::string s = tep_cli[i].recv();
            int x = std::atoi(s.c_str());//æ€æ­»ç¬¬å‡ å®¢æˆ·ç«¯
            tep_cli[x].selfCharacter() ->set_dead();
        }
    }
    return true;
}
